	For my sliding window algorithm I had a few unique solutions to problems that I encountered, but also implemented common solutions to  many of the problems that arose while constructing a server and client that utilizing the UDP protocol.  
	The first steps that I took while beginning this assignment was to first create a simple TCP server and client connection.  From this basic structure of opening and closing sockets I began to forge a UDP connection between the two.
	My first fray into the UDP connection began with the construction of a legal packet that would be able to hold the necessary data such as sequence number, actual data, and eventually a checksum.  The language that I choose to program in was Python.  With Python a list is the data structure of choice, in this case it was no different.  For my construction of a packet I first create a list and begin to append the necessary components to this list before transmission.  First sequence number which is incremented by one at each construction of a packet.  I than pack the packet with data that is read from the byte stream of the input file.  Lastly I choose to put the checksum into the packet as a hash algorithm.  This hash algorithm is fed the data that was previously entered into the packet in order to construct this algorithm.  Lastly before transmitting the packet I convert it into a string as the socket "sendto" method only supports the sending of a string.  To address this challenge I needed to "pickle" my newly constructed list in order to serialize the data thus converting it to string type and being able to be transmitted.
	This process of creating a packet was one of the one the most difficult concepts to piece together due to the nature of bringing together so many different ideas and different sections that build onto one another.
	Another challenge for this assignment was how to signify to the sender that the packet that had freshly been crafted and sent were received by the receiver.  How to correctly handle the packets that were being sent and how to correctly acknowledge back to the sender that these packets were received was the next challenge of this assignment.  It was necessary for my receiver to first, after receiving the packet to transmit it from the pickled and serialized string version back to the list format that it was originally in before transmission (a list data structure).  After reverting the packet I extracted the set checksum that was generated using hashlib.md5 and than proceed to recreate this secure hash using the just transmitted data.  If the the hash contained within the packet received and the hash that was newly generated from the data contained within the packet do not match the data has been corrupted.  Acknowledgement is not sent from the receiver and a timeout of not receiving acknowledgement of a sent packet is not sent back to the sender.  This triggers a timeout and a retransmission by the sender of the packet.
	Although if the packet generated a matching hash with the provided hash within the packet my receiver would proceed to add the data from the packet into a list of all data and than send a acknowledgment of the packet received correctly.  This acknowledgment contained the sequence number sent and allowed for the sender to terminated the thread created when a packet is first transmitted.  Another large issue with the receiver was when to ignore a repeated packet.  This may occur when the acknowledgement was dropped while in transmission back to the receiver.
	One of the final pieces of my sliding window algorithm was to implement threads to send each packet from the sender to the receiver.  Each thread sent each packet individually.  This allowed for the number of packets being sent at one time to be tracked and never exceed the window size that was set.  This made it more manageable to control the number of packets being sent at a time to the receiver.
	Finally I needed to make sure that while packets were received were than written in order to the file otherwise the file would have ultimately failed in transmission.  I controlled this using a holder value of the last place written and would continue to write from this holder variable.
	This assignment was great challenge and I feel much more comfortable with many of the principles of network programming because of these challenges.